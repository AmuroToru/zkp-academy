# STARK 101 学习笔记

该笔记是学习 STARKWARE 的 STARK 101 课程所做记录。

## STARK 101: 第一、二部分

STARK 101 的第一部分和第二部分主要描述如何将一个具体问题算数化（arithmetization）。目前大多数的证明系统支持证明的语言都为多项式形式，因此我们在 STARK 中也需要算数化的过程。

STARK 采用的证明系统是对近似性质的交互式随机预言机证明（Interactive Oracle Proofs of Proximity, IOPP），是基于交互式随机预言机证明（Interactive Oracle Proofs, IOP）的一个变体。IOP 是交互式证明（Interactive Proofs, IP）和概率可检验证明（Probabilistic Checkable Proofs, PCP）的结合，既允许证明者和验证者进行多轮交互（IP），也允许每轮交互中验证者可以随机访问证明者的证明（PCP）。

一个证明系统需要满足两个性质完备性（completeness）和健壮性（soundness），完备性要求诚实的证明者输出的证明可以通过验证，健壮性要求不诚实的证明者输出的证明不可以通过验证（通常情况下，这里的“可以”也可替换为“极大概率“）。

相较于 IOP，IOPP 在健壮性的要求上做出了让步，不诚实的证明者输出的证明和诚实的证明者输出的证明差异较大的情况下，才不可以通过验证。此时，如果不诚实的证明者输出的证明与诚实的证明者相差较小，也可能通过验证，增加了作恶的风险。

STARK 的算术化利用了一种放大差异的特性，来避免这个问题，即不诚实的证明者总是输出差异较大的证明。

### 斐波拉契平方序列

在本课程中，我们将用 STARK 协议证明关于斐波拉契平方序列（Fibonacci Square, FibonacciSq）的声明。

FibonacciSq 中的每一项为前两项的平方和，即给定 $a_0,a_1$，它的通项公式为： $a_{n+2}=a_{n+1}^2+a_{n}^2$。

如果在有限域 $\mathbb{F}_q$ 中，定义 FibonacciSq，那么通项公式为 $a_{n+2}=a_{n+1}^2+a_{n}^2 \quad (\mathrm{mod\ } q)$。

示例：在有限域 $\mathbb{F}_7$ 中，有如下 FibonacciSq：$1,3,3,4,4,4,\dots$。

在本课程中，我们将用 STARK 协议证明如下声明：

> 证明者知晓域元素 $x=3141592\in \mathbb{F}_q$，使得定义在 $\mathbb{F}_q$ 中的 FibonacciSq（$a_0 = 1, a_1 = x$）有 $a_{1022} = 2338775057$，其中 $q=3221225473 = 3 \cdot 2^{30} + 1$。

### 低度扩展

低度扩展（Low Degree Extension, LDE）是一种在零知识证明系统（例如 STARK 协议）中使用的数学技术。它的主要目的是将定义在较小的集合上的函数扩展到较大的集合上，同时保持函数是一个低度多项式。

LDE 一般分为三个步骤，输入、插值、扩展。

1. 输入：准备较小集合上的数据点（如 $( (x_1, y_1), (x_2, y_2), \dots, (x_n, y_n) $)。
2. 插值：使用拉格朗日插值法构建一个多项式 $f(x)$，使得 $\forall\ i \in [n], f(x_i) = y_i$。
3. 扩展：在较大的集合上，准备新的数据点坐标 $(x_1',x_2',\dots,x_n',\dots)$，计算多项式 $f(x)$ 在这些点上的值：$(f(x_1'),P(x_2'),\dots,f(x_n'),\dots)$。

在 STARK 中，我们需要对 FibonacciSq 序列做 LDE。具体步骤如下：

首先我们记有限域 $\mathbb{F}_q$ 所对应的乘法群为 $\mathbb{F}_q^{\times}$，其生成元为 $w$；记 $\mathbb{F}_q^{\times}$ 中一个较小的子群（$1024$ 个元素）为 $G=\{g^0,\dots,g^{1023}\}$，一个较大的子群（$8192$ 个元素）为 $H=\{h^0,\dots,h^{8191}\}$，斐波拉契平方序列 $a=(a_0,\dots,a_{1022})$。我们可以做如下 LDE：

1. 输入：准备较小集合上的数据点（$((g^0,a_0),(g^1,a_1),\dots,(g^{1022},a_{1022}))$）。
2. 插值：使用拉格朗日插值法构建多项式 $f(x)$，使得 $\forall\ i \in [0,1022], f(g^i) = a_i$。
3. 扩展：在较大的集合上（$H$ 的左陪集 $wH=\{w\cdot h^0,w\cdot h^1,\dots,w\cdot h^{8191}\}$）上，计算多项式 $f(x)$ 在这些点上的值：$(f(w\cdot h^0),f(w\cdot h^1),\dots,f(w\cdot h^{8191}))$。

原先我们对 $1023$ 个数据点进行插值，可以得到一个最高次为 $1022$ 的多项式，即包含了 $1022$ 个信息符号。LDE 通过在较大的集合上扩展多项式，得到 $8192$ 个点，实现了与 Reed-Solomon 编码类似的冗余信息生成能力，从而增强了信息的错误检测和纠正能力。

#### Reed-Solomon 编码

Reed-Solomon（RS）编码是一种广泛应用的纠错编码技术。假设有 $k$ 个信息符号，表示为 $\{m_0,m_1,\dots,m_{k-1}\}$，每个信息符号都是有限域 $\mathbb{F}_q$ 中的元素，这些符号可以构造多项式 $$P(x)=m_0+m_1x+\dots+m_{k-1}x^{k-1}.$$

这些符号的 RS 码字（Codeword） $\mathbf{c}$ 可以通过求多项式 $P(x)$ 在乘法群为 $\mathbb{F}_q^{\times}$ 上 $q$ 个不同点处的取值得到，即 $$\mathbf{c}=(P(\omega^0),\dots,P(\omega^{q-1})).$$

该码字可以表达为如下的线性方程组的形式：

$$\begin{bmatrix} 1 & \omega^0 & \cdots & \omega^0  
\\ 1 & \omega^1 & \cdots & \omega^{k-1} 
\\ \vdots &  \vdots & \ddots & \vdots
\\ 1 & \omega^{q-1} & \cdots & \omega^{(q-1)(k-1)}\end{bmatrix} 
\begin{bmatrix} m_0 \\ m_1 \\ \vdots \\ m^{k-1}\end{bmatrix}=
\begin{bmatrix} P(\omega^0) \\ P(\omega^1) \\ \vdots \\ P(\omega^{q-1})\end{bmatrix}.$$

从码字 $\mathbf{c}$ 的任意 $k$ 个符号，我们都可以唯一的解出 $k$ 个变量 $\{m_0,m_1,\dots,m_{k-1}\}$。

码字 $\mathbf{c}$ 中隐藏了原始信息符号 $\{m_0,m_1,\dots,m_{k-1}\}$，如果我们构造多项式 $P(x)$ 使得 $P(\omega^0)=m_0,P(\omega^1)=m_1,\dots,P(\omega^{k-1})=m_{k-1}$，然后完成编码，这样得到的码字中没有隐藏原始的信息符号，所以能够使译码更加直观，正类似我们在 LDE 中所做的。

## 多项式约束

我们所要证明的关于 FibonacciSq 的陈述有 3 个已知条件（约束）：

1. $a_0=1$，
2. $a_{1022}=2338775057$，
3. $a_{n+2}=a_{n+1}^2+a_{n}^2$。

如果 FibonacciSq 满足这三个约束，那么陈述为真，即证明者知道 $a_1=x$。

在 LDE 中，我们将 FibonacciSq  转化为了一个等价的多项式 $f(x)$，使得 $\forall\ i \in [0,1022], f(g_i) = a_i$，那么关于 FibonacciSq 的 3 个约束可以转化为 3 个多项式约束：

1. $f(g^0)=1$，
2. $f(g^{1022})=23387755057$，
3. $f(g^2x)=f(gx)^2+f(x)^2, {\rm where\ }x=g^i,0\leq i \leq 1020$。

根据因式定理（若多项式 $g(a)=0$，则多项式 $g(x)$ 必定含有因式 $x-a$，即 $\frac{g(x)}{x-a}$ 仍为多项式），上述三个条件可以转化为关于多项式整除的约束：

1. $p_0(x)=\frac{f(x)-1}{x-g^0}$，
2. $p_1(x)=\frac{f(x)-23387755057}{x-g^{1022}}$，
3. $p_2(x)=\frac{f(g^2x)-f(gx)^2-f(x)^2}{\prod_{i=0}^{1020}(x-g^i)}=\frac{f(g^2x)-f(gx)^2-f(x)^2}{(x^{1024}-1)/\prod_{i=1021}^{1023}(x-g^i)}$。

此时，如果多项式 $p_0(x),p_1(x),p_2(x)$ 都是多项式，那么陈述为真。

进一步地，我们可以选取随机数 $\alpha_0,\alpha_1,\alpha_2$，令 $CP=\alpha_0 p_0(x)+\alpha_1 p_1(x)+\alpha_2 p_2(x)$。此时，若 $CP$ 为多项式，那么 $p_0(x),p_1(x),p_2(x)$ 都是多项式，亦即若 $CP$ 为多项式，那么陈述为真。

## 承诺方案

在 STARK 中，使用的承诺（commitment）方案为默克尔树（Merkle Tree）。对一个多项式 $f(x)$ 的承诺方案为计算这个多项式在定义域中每个值 $x\in D$ 的多项式值 $f(x)$ 的哈希值，然后按照默克尔树的方案（如下图）计算出根节点哈希值，发送给验证者。

![MerkleTreeforLDE](STARK 101 学习笔记/MerkleTreeforLDE.png)

在基于默克尔树的承诺方案中，验证者向证明者发出随机挑战（challenge）$c$，证明者计算函数值 $f(c)$，并生成对应的默克尔树路径（从需要验证的叶子节点开始，向上找到它的兄弟节点（即同一父节点的另一个子节点），将这些兄弟节点的哈希值依次记录，直到到达根节点。这个哈希值的序列就是默克尔树路径） 。

验证者可通过验证默克尔树路径最终生成的哈希是否与先前接受的根节点哈希值是否匹配，来确认挑战是否成功。

## STARK 101: 第三部分

第三部分介绍如何使用 FRI（Fast Reed-Solomon Interactive Oracle Proofs）证明 $CP$ 是多项式。

### 多项式的近似

在 FRI 中，我们并不直接证明 $CP$ 是多项式，而是证明 $CP$ 近似于一个低度的多项式。我们需要解决解决两个问题：何为近似，何为低度。

低度指的是证明者和验证者约定的度数边界，在本例中，低度是较小集合的基数。

近似指的是多项式之间的接近程度，我们可以采用如下定义：令 ${\sf Dis}(f,p)$ 为在函数 $f$ 的定义域 $D$ 中，函数值 $f(x)\neq p(x)$ 的 $x$ 的数量，我们称 ${\sf Dis}(f,p)$ 为函数 $f$ 和多项式 $p$ 的距离。 如果函数 $f$ 和多项式 $p$ 是近似的，那么 ${\sf Dis}(f,p)$ 很小。

### FRI 算子

一个 FRI 协议包括四个步骤：接收随机数 $\beta$，运行 FRI 算子（operator），承诺（commitment），重复上述三个步骤，最后发送证明。

FRI 算子的具体操作为，对于一个随机数 $\beta$，将一个多项式函数 $F_0(x)$，表达为两个多项式之和，即 $F_0(x)=g(x^2)+xh(x^2)$，其中 $g(x^2)$ 的系数对应 $f(x)$ 中偶次幂的系数， $h(x^2)$ 的系数对应 $F(x)$ 中奇次幂的系数。

此时，构造新的多项式函数 $F_1(x)=g(x)+\beta h(x)$，$F_1(x)$ 的次数为 $F_0(x)$ 次数的一半（向下取整），$F_1(x)$ 定义域的大小亦为 $F_0(x)$ 定义域大小的一半（在 $F_0(x)$ 的定义域（乘法群）中，对每个元素计算其平方，可以得到 $F_1(x)$ 的定义域（乘法子群），其个数是 $F_0(x)$ 的定义域的一半）。

FRI 算子的作用是折半减小问题的规模，例如，“证明一个定义域大小有 8192 个元素的函数 $f$ 近似于一个最高次数小于 1024 的多项式“。运行 1 次 FRI 算子之后，该问题可以变成“证明一个定义域大小有 4096 个元素的函数 $f$ 近似于一个最高次数小于 512 的多项式“。运行 FRI 算子 10 次后，问题可以变成“证明一个定义域大小有 8 个元素的函数 $f$ 近似于一个最高次数小于 1 的多项式“，即“证明一个定义域大小有 8 个元素的函数 $f$ 近似于一个常数“。

## STARK 101: 第四部分

第四部分介绍 FRI 中如何取信验证者，即证明者承诺了什么，验证者如何验证。

### 承诺

在证明者计算过程中，证明者首先拥有一条关于陈述的计算轨迹（trace），在本例中，为 LDE 的输出，即函数 $f$ 在较大集合上的函数值，我们对所有的函数值计算哈希值，作为默克尔树的叶子节点，并计算根节点的哈希值，记作 Trace Root。

其次，证明者将计算轨迹转换为多项式约束问题，得到一个多项式 $CP$，同样地，计算 $CP$ 在较大集合上的函数值，并计算其默克尔树，记根节点哈希值为 $CP$ Root。

令 $CP_0=CP$，在 FRI 过程中，第 $i$ 轮算子操作，验证者随机发送挑战 $\beta_i$ 给证明者，证明者折半当前的多项式 $CP_{i-1}$ 得到 $CP_i$，对 $CP_i$ 计算默克尔树，记根节点哈希值为 $CP_i$ Root。直到多项式 $CP_i$ 的次数小于 $1$。

最终，证明者，将所有的根节点哈希值（Trace Root, $CP$ Root, $CP_1$ Root, $\dots$）发送给验证者，见下图。这些根节点哈希值构成了证明者的承诺，即计算轨迹是正确的。

![HighlevelFRI](STARK 101 学习笔记/HighlevelFRI.png)

### 验证

接下来，验证者将对证明者发起多轮挑战，来判断证明者承诺的正确性。

在每一轮挑战中，验证者随机发送挑战 $x$，$x$ 在较大的集合中。证明者首先计算该挑战在 Trace 中的函数值 $f(x),f(gx),f(g^2x)$（这三个值可以计算出 $CP(x)$）以及每个函数值对应的默克尔树路径，将函数值和对应的默克尔树路径发送给验证者。接下来在函数 $CP_0$ 以及 FRI 的每一轮算子操作得到的函数 $CP_i,i\geq 1$ 上计算函数值 $CP_i(x^{2^{i}})$ 和 $CP_i(-x^{2^{i}})$，以及它们对应的默克尔树路径。

注：因为 $CP_i(x)=g(x^2)+xh(x^2),CP_{i}(-x)=g(x^2)-xh(x^2)$，所以 $CP_{i+1}(x^2)=g(x^2)+\beta_{i+1} h(x^2)$ 可由 $CP_i(x)$ 和 $CP_i(-x)$ 计算而出。 

最终，在每一轮挑战中，验证者随机发送一个挑战 $x$，证明者计算并发回多个函数值以及对应的默克尔树路径。验证者可以验证默克尔树路径是否和先前的根节点哈希值匹配以及函数值之间的等式关系是否成立。

![decommitment](STARK 101 学习笔记/decommitment.png)

总结：在一次证明中，证明者首先向验证者发送了 $O(\log n)$ 个默克尔树根节点哈希值，其中 $n$ 是要证明的多项式的次数。在每一轮验证者的挑战中，证明者发送了 $O(\log n)$ 个函数值，以及其对应的默克尔树路径，每条路径大小约为 $O(\log n/2^i)$，$i$ 为当前 FRI 层次。 

### 参考资料：

1. https://github.com/starkware-industries/stark101
2. https://github.com/Antalpha-Labs/zkp-academy/blob/main/FRI%26Stark/stark101
3. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh and Michael Riabzev. “Fast Reed-Solomon Interactive Oracle Proofs of Proximity.” *ECCV* (2017).
